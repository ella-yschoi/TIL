# 02. 컴퓨터 시스템의 구조

> Reference: [이화여자대학교 운영체제 강의 - 반효경](http://www.kocw.net/home/cview.do?cid=4b9cd4c7178db077)

## 운영체제의 종류

### 운영체제에 따른 오픈/비공개 소스 여부

- Windows: Closed Source Software
- Linux: Open Source Software
- Android:  Open Source Software (최하단에 Linux Kernel 포함)

### 어떻게 Open Source가 가능한가?

- Software 특성상 인건비를 제외한 원재료비가 들지 않기 때문
- 독점 체제가 가능한 시장이므로 1등 소프트웨어는 잘 팔고 나면 시장 장악하지만, 1등 외의 경쟁자들은 도태됨
- 2등 소프트웨어는 도태되기 전에 오픈하여, 사용자들이 여러 환경에 맞게 소스코드를 적용하여 점차 점유율이 높아지도록 함

## 운영체제란 무엇인가?

### 운영체제란?

- 컴퓨터 하드웨어 바로 위에 설치되어, 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층

### 운영체제의 의미

- 좁은 의미의 운영체제 (커널)
  - 운영체제의 핵심으로, 메모리에 상주하는 부분
- 넓은 의미의 운영체제
  - 커널 뿐만 아니라, 각종 주변 시스템 유틸리티를 포함한 개념

## 운영체제의 목적

- 컴퓨터를 **편리하게** 사용할 수 있는 인터페이스 제공
- 컴퓨터 시스템의 자원을 **효율적**으로 관리 (소프트웨어, 하드웨어 모두)
- 각각의 사용자는 하드웨어가 어떻게 실행되는지 모르도록 **운영체제가 대행**

### CPU의 역할

- CPU가 컴퓨터의 두뇌이긴 하나, 판단하는 능력은 없고 써져있는대로 빠르게 계산하고 실행함
- 따라서 어떻게 보면 컴퓨터의 두뇌는 CPU보단, 운영체제라고 볼 수도 있음
- CPU는 **계산**을 하고, 메모리는 **기억**을 하는 존재

### 운영체제의 역할

- 운영체제는 효율적으로 관리 및 운영하는 **통치자의 역할**이라고 보면 됨
- 한정된 메모리 공간에 동시에 여러 프로그램이 올라가면 적절히 할당하는 역할

## 운영체제의 분류

### 동시 작업 가능 여부

- 단일 작업 (single tasking)
  - 한번에 **하나의 작업만** 처리
  - e.g. MS-DOS 프롬프트 상에서는 한 명령의 수행을 끝내기 전에 다른 명령을 수행시킬 수 없었음
- 다중 작업 (multi tasking)
  - 동시에 **두 개 이상**의 작업 처리
  - 다중 사용자가 쓸 수 있도록 보안/권한 문제에 대한 해결 필요
  - e.g. UNIX, MS Windows 등에서는 한 명령의 수행이 끝나기 전에 다른 명령이나 프로그램 수행 가능

### 사용자 수

- 단일 사용자 (single user)
  - e.g. MS-DOS, MS Windows
- 다중 사용자 (multi user): 동시 접속
  - UNIX, NT server
  - 다중 사용자가 쓸 수 있도록 보안/권한 문제에 대한 해결 필요

### 처리 방식

- 일괄 처리 시스템 (batch processing OS)
  - 작업 요청의 **일정량을 모아서 한꺼번에** 처리
  - 작업이 완전 종료될 때까지 기다려야 함
  - e.g. 초기 입출력하던 Punch Card 처리 시스템
  - e.g. ‘사용자를 생각해서 바로 결과를 보여주지 않고, 내가 편한대로 하겠다!’
- 시분할 시스템 (time sharing OS)
  - 여러 작업을 수행할 때 컴퓨터 처리 능력을 **일정한 시간 단위로 분할**하여 사용
  - 일괄 처리 시스템에 비해 **짧은 응답 시간**을 가짐
  - **Interactive**한 방식: 사용자를 생각해서 **바로 결과**를 보여줌
  - 컴퓨터를 동시에 사용해도, 시간을 분할해서 **마치 혼자** 사용하는 것처럼 보여줌
  - e.g. UNIX, 보통의 사용자가 이용하는 시스템
- 실시간 시스템 (Realtime OS)
  - 정해진 시간 안에 어떠한 일이 **반드시 종료됨이 보장**되어야 하는 실시간 시스템을 위한 OS
  - **Deadline**이라는 개념이 존재하고, 반드시 만족해야 함. 어기면 아주 치명적인 결과를 초래함
  - e.g. 원자로/공장 제어, 미사일 제어, 반도체 장비, 로봇 제어
  - 경성 실시간 시스템 (Hard realtime system)
    - Deadline을 어기면 상당히 치명적
  - 연성 실시간 시스템 (Soft realtime system)
    - Deadline을 어기면 상대적으로 덜 치명적
    - e.g. 동영상 플레이어 재생 시 프레임이 찍히지 않으면 영상이 끊김

### 용어 정리

아래 용어들은 컴퓨터에서 여러 작업들을 동시에 수행하는 같은 의미이나, 조금씩 강조하는 바가 다름.

- Multi-tasking
- Multi-process
- Multi-programming
  - memory 측면을 강조한 것
  - memory 위에 동시에 여러 프로그램들이 올라가 있다는 의미
- Time sharing
  - CPU 측면을 강조한 것
  - 주로 CPU의 시간을 분할하여 쪼개 쓴다는 의미

아래 용어는 아예 다른 의미

- Multi-processor
  - 하나의 컴퓨터에 CPU(Processor)가 여러 개 붙어 있음을 의미
  - 다만, 일반적인 환경은 아니고 고성능 컴퓨팅, 클라우드 컴퓨팅 분야에서 다룸

## 운영체제의 예시

### UNIX

- 역사
  - 원래는 하드웨어적인 것도 관리가 필요해 assembly 언어로 개발이 매우 어려웠음
  - 이후 C언어의 등장으로 개발 및 수정이 수월하고 사람이 이해하기 편해짐
- 특징
  - 코드의 대부분을 C언어로 작성
  - C언어는 여러 아키텍처에서 호환이 되므로 **높은 이식성**을 가짐
  - 서버를 위한 운영체제 → 따라서 여러 프로그램, 여러 사용자 관리 필요
  - 최소한의 Kernel 구조
  - 오픈 소스
  - 프로그램 개발과 확장이 용이
  - 버전이 다양함 (e.g. Linux의 경우, 오픈소스이므로 이것을 기반으로 발전중)

### DOS (Disk Operating System)

- 역사
  - MS사에서 1981년에 IBM-PC를 위해 개발
- 특징
  - 단일 사용자용 운영체제
  - 메모리 관리 능력에 한계가 있음 (주 기억장치: 640KB)

### MS Windows

- 특징
  - MS사의 다중작업용 GUI 기반 운영체제
  - Plug and Play: 컴퓨터에 하드웨어를 연결하면 별도의 사용자 조작이나 프로그램 설치 없이 바로 사용할 수 있음
  - 네트워크 환경 강화
  - DOS용 응용 프로그램과 호환성 제공
  - 풍부한 지원 소프트웨어

## 운영체제의 구조

![OS_structure](/Images/OS_structure.png)

## 컴퓨터 시스템의 구조

## Mode bit

### Mode bit이란?

- 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 **운영체제에 피해가 가지 않도록 하기 위한 보호장치**

### Mode bit의 필요성

- CPU가 사용자 프로그램에 넘어가면 **운영체제는 제어할 수 없기 때문**
- CPU에서 기계어를 실행할 때 운영체제 or 사용자 프로그램이 실행하는지 **구분하는 존재**가 필요함
- CPU가 제어 가능한 위치가 아닐 때 (다른 일을 하고 있을 때) mode bit이라는 것을 두어서 권한 제어를 하는 것
- 즉, Mode bit은 **안전한 기계어만 실행**할 수 있게끔 하여 **시스템을 보호**하는 역할

### Mode bit의 종류

Mode bit을 통해 하드웨어적으로 두 가지 모드의 operation 지원

- 1 (사용자 모드)
    - 사용자 프로그램 수행
    - 운영체제가 CPU로 무슨 일이든 할 수 있음
- 0 (모니터 모드)
    - OS 코드 수행
    - 운영체제가 사용자 프로그램에게 넘겨줄 때
    - 커널 모드, 시스템 모드 라고 부르기도 함

### Mode bit의 원리

- 보안을 해칠 수 있는 중요한 명령어는 **0 (모니터 모드)에서만 수행 가능한 ‘특권 명령’**으로 규정
- Interrupt나 Exception 발생 시, 하드웨어가 **Mode bit을 0으로** 세팅
- 사용자 프로그램에게 CPU를 넘기기 전에 **Mode bit을 1로** 세팅

### Mode bit 전환 방식

- Exception
    - 권한이 없는 기계어 실행 시, **Mode bit이 0으로 바뀌면서** CPU 사용권이 운영체제에 넘어감
    - 이는 권한이 없는 작업을 실행하려고 할 때 발생하는 Exception을 뜻함
- Interrupt
    - Interrupt line에서 매순간 기계어를 읽다가, 다음 기계어를 읽을 때 line에서 I/O 장치들이 준 다른 요청이 들어온건 없는지 체크
    - 이는 CPU Interrupt를 의미 (from Disk controller, I/O controller, etc.)

## Registers

### Registers란?

- 연산의 input과 output을 저장하기 위한 빠르고 작은 크기의 것으로, CPU에 붙어 있음

### Registers의 종류

- PC (Program Counter) Register
    - 다음번에 실행할 기계어의 memory의 주소를 가지고 있음 → 주소를 가리키고 있다는 뜻
    - CPU는 PC Registers가 가리키고 있는 memory 주소의 기계어를 실행
    - 실행이 끝나면 그 다음 위치의 기계어를 실행
    - CPU Interrupt가 발생하면 PC Registers가 바라보고 있는 memory는 OS가 됨

## Timer

### Timer란?

- 프로그램으로부터 CPU 사용권을 빼앗아 오는 것

### Timer의 역할

- 일정 시간이 지나면 Interrupt 를 발생 → **CPU의 사용권을 뺏어오는 역할**
    - CPU 사용권을 뺏어오는 작업은 OS가 혼자 할 수 없음
    - 정해진 시간이 흐른 뒤 **OS에게 제어권이 넘어가도록 Interrupt를 발생**
    - **CPU의 독점을 막기 위한 hardware**가 필요 → 바로 Timer
- Time sharing을 구현하기 위해 널리 이용되며, 시간 계산 목적으로도 사용됨

### Timer의 동작 방식

- Timer는 매 clock tick 마다 1씩 감소
- Timer 값이 0이 되면 Timer Interrupt가 발생
- 운영체제가 사용자 프로그램에게 넘길 때 그냥 넘기는 것이 아닌, Timer에 시간을 세팅하고 넘겨줌
- 따라서 무한루프를 돌면서 CPU를 계속 쓰고 싶더라도 Timer가 CPU에게 interrupt를 걸기 때문에 CPU의 제어권이 운영체제에게 넘어옴 → 운영체제가 다른 프로그램에게 CPU 사용권을 넘겨주는 방식

## Interrupt

- timer가 interrupt를 걸었다면, 운영체제와 협력해서 CPU의 독점권을 막기 위함
- CPU가 기계어를 실행하다가 파일을 읽어올 때, 느린 I/O장치에서 가져오려고 할 때 CPU가 직접 접근을 못하니까 파일 읽어올 때는 기계어를 통해 읽지 못하니 CPU는 디스크를 전담하는 컨트롤러에게 별도의 기계어(특권 명령인 기계어)로 부탁
- 모든 I/O 장치를 접근하는 (즉, CPU가 I/O를 해달라고 하는) 명령어는 전부 특권 명령어로 묶여 있다. 이는 운영체제에게 해달라고 요청 → 시스템 콜

### Interrupt란?

- Interrupt 당한 시점의 Registers와 Program Counter를 save한 후, CPU의 제어를 Interrupt 처리 루틴에 넘김

### Interrupt의 넓은 의미

- Interrupt (하드웨어 Interrupt) : 하드웨어가 발생시킨 Interrupt
- Trap (소프트웨어 Interrupt)
    - Exception: 프로그램이 오류를 범한 경우
    - System Call: 프로그램이 커널 함수를 호출하는 경우

## System Call

- 사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것
- 사용자 프로그램이 실행되다가 → 디스크에서 읽어와야 겠다 → 내가 CPU 기계어로는 특권명령을 못하기 때문에 → 스스로 운영체제를 불러서 대신 해주세요 요청 → 시스템 콜 → 사용자 프로그램 위치에서 기계어 실행되다가 → 운영체제로 기계어 실행되는 점프 : 프로그램의 가상메모리를 가로질러서 점프함
- 이 프로그램이 스스로 interrupt를 검 → system call
- 직접 program counter를 넘길 수 없기 때문에 자신의 기계어로 interrupt line을 형성 → 운영체제에게 CPU 사용권을 넘김

## Device Controller

- Device Controller: 하드웨어
- CPU: 하드웨어
- I/O 장치의 펌웨어라는 미리 코딩된 프로그램이 들어 있기에 동작이 됨
- Device Driver: 소프트웨어
    - OS 코드 중 각 장치별 처리 루틴 (코드는 아니고 운영체제 안의 코드중에서 CPU가 부탁하는 기계어임)
    - Device Controller가 수행하는 코드가 아닌, CPU가 수행하는 코드임
    - Device Driver에서 수행되는 코드는 펌웨어라고 함