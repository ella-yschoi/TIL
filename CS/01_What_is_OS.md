# 01. 운영체제 개요

> Reference: [이화여자대학교 운영체제 강의 - 반효경](http://www.kocw.net/home/cview.do?cid=4b9cd4c7178db077)

## 운영체제(Operating System, OS)란?

  ![what_OS.png](/Images/what_OS.png)

- 컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 **모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층**
- 다른 응용 소프트웨어와는 다르게, 하드웨어를 직접 관리하고 편리한 인터페이스를 제공해야 함

## 운영체제의 목적

- (1) 컴퓨터 시스템을 **편리하게 사용할 수 있는 환경을 제공**
  - 다른 사용자와 프로그램들이 각각 독자적 컴퓨터에서 수행되는 것 같은 환상을 제공
  - 하드웨어를 직접 다루는 복잡한 부분을 운영체제가 대행
- (2) 컴퓨터 시스템의 **자원을 효율적으로 관리**
  - CPU, 메모리, I/O(Input&Output) 장치 등의 효율적 관리
    - 주어진 자원으로 최대한의 성능을 내도록 → **효율성**
    - 특정 사용자/프로그램의 지나친 불이익이 발생하지 않도록 → **형평성(round robin 개념)**
    - 실행중인 프로그램들에 짧은 시간씩 CPU를 번갈아 할당
    - 실행중인 프로그램들에 메모리 공간을 적절히 분배
  - 사용자 및 운영체제 자신의 보호

## 컴퓨터 시스템의 구조

  ![computer_system.png](/Images/computer_system.png)

- I/O
  - 디바이스들에 데이터가 들어가는 것 → Input
  - 결과를 내보내는 것 → Output
  - ex) 하드디스크(보조기억장치)
    - Input과 Output을 모두 할 수 있는 장치
    - 처리(Input)와 저장(Output)을 모두 할 수 있음
    - 즉, read와 write를 모두 할 수 있음

## 운영체제의 기능

  ![os_function.png](/Images/os_function.png)

- 컴퓨터가 부팅된다 == 메모리에 운영체제가 올라간다.
  - 핵심은 커널: 메모리에 상주하면서 언제나 메모리에 올라와 있는 부분
- 나머지(운영체제가 CPU에게 작동을 스케줄링해서 일하라고 시킨 프로그램 A~C): 메모리 공간을 차지하는 것
  - e.g. 터미널에서 명령어 `htop` 입력하면 나오는 리스트
- CPU의 작업공간 == 메모리
  - CPU는 매 clock마다 기계어를 읽어서 연산을 함
- I/O 디바이스들은 일종의 작은 CPU가 붙어 있음 (I/O 컨트롤러)
  - CPU가 ‘파일을 읽어주세요’ 요청 → 요청된 파일을 읽어서 작은 메모리 공간에 읽음 → CPU에게 다 했다고 함 → CPU가 메모리에 올라온 것을 읽어다가 일을 함

## CPU 스케줄링

  ![cpu_scheduling.png](/Images/cpu_scheduling.png)

- **어떤** 프로그램에게 **얼마동안** CPU 사용권을 줄까?
- CPU는 직접 쓰라고 하지 못하고, 기계어를 읽어서 시키는 일만 함
- 운영체제가 가지고 있는 기계어로 CPU에게 시킴 (운영체제의 대행)
- 운영체제가 CPU를 관리할 때는 무한히 쓰게 하지는 않고, 한정된 시간동안만 쓰게 함 → 운영체제는 시간이 지나면 사용권을 빼앗아 오는 역할을 함.
- 단, 하드웨어와 협조해서 스케줄링을 진행함

## 메모리 관리

  ![memory_managing.png](/Images/memory_managing.png)

- 한정된 메모리를 어떻게 쪼개서 쓸까?

## 디스크 스케줄링

  ![disc_scheduling.png](/Images/disc_scheduling.png)

- 요청이 먼저 온 순서대로 처리해도 되지만, 비효율을 유발할 수도 있음.
- 운영체제 목적이 ‘효율성’ 이므로 나중에 들어온 요청이지만 순서를 뒤바꿔서 효율적으로 운영할 수 있도록 할 수 있도록 함
- e.g. 엘레베이터 스케줄링과 유사
  - 10층 사람보다 2층 사람이 버튼을 늦게 눌렀지만 어차피 1층에서 10층 가는 길이라면 2층 사람을 먼저 태워주는 원리

## 인터럽트, 캐싱

  ![interrupt_caching.png](/Images/interrupt_caching.png)

- 빠른 CPU와 느린 I/O 장치 간의 속도 차를 극복할 수 있는 방법
- Caching(캐싱)
  - 중간 단계를 두는 것.
  - 디스크에서 파일을 읽어달라는 요청이 왔을 때 처리하는게 아니라 (똑같은 데이터를 또 읽어야 할 수도 있으니) **메모리 어딘가에 보관**해두었다가 메모리의 복제본으로 읽어가는 개념
- Interrupt(인터럽트)
  - **느린 I/O들이 작업이 완료되었다는 것을 알린다**
  - CPU가 직접 I/O 작업을 하는게 아니라 디스크 컨트롤러에게 파일을 읽어달라고 부탁 → 그동안 CPU는 당장 일할 수 있는 것을 찾음 (→ CPU 스케줄링) 즉, CPU는 빠른 아이이므로 놀게 두지 않고 무엇이든 하게 놔둔다.
  - 파일을 다 읽었다면? → 프로그램 A가 요청을 다 읽었다는 것을 CPU에게 전달함 → Interrupt
  - 느린 장치들에게 일을 시켜놓고, CPU에게 일 끝났는지 확인하는건 비효율적이므로 시킨 일이 끝나서 CPU에게 연락해야 할 때 (아주 가끔) interrupt를 걸어줌
  - 예시
    - 팀장이 팀원 A, B, C에게 일을 시킴 → 팀원 A가 팀장에게 "일 다했어요" 라고 알리는 interrupt → 팀장이 팀원의 말로 인해 interrupted 되어서 팀원 A의 일을 봐줌 → 그리고 결국 사장 앞에서 프레젠테이션하는건 팀장
    - 즉, CPU가 해야 하는 일을 디스크 관련 일을 디스크 컨트롤러에게 임시로 위임했으니, 컨트롤러가 다했으면 → interrupt → 읽는 작업이 완료된 이후 작업 (보여주는 것 등)을 CPU가 함
    - Blocking: 팀장이 팀원의 일을 잘 했는지 잡아서 확인한다.
    - Non-blocking: 팀장과 팀원의 일을 각자 한다.

## 프로세스의 상태

  ![process_queue.png](/Images/process_queue.png)

- CPU가 하나밖에 없기 때문에, 기계어를 실행하는 것이 CPU 안에서 이루어짐
- 나머지들은 CPU를 못쓰고 기다리고 있는데, 운영체제가 CPU 쓰고자 하는 애들에게 '큐'라는 것을 만들어줌 → 짧은 시간동안 빼서 CPU를 쓸 수 있도록 줄세워 둠
- 디스크에 있는 파일을 읽어와야겠다 → 디스크 입출력 큐에 프로세스가 쌓이면 → CPU 스케줄링에 의해 처리됨 → interrupt → 디스크 큐에서 빼서 → CPU 큐에 넣어줌
- Interacive Application
  - 프로그램 중 사람과 interaction하는 프로그램 (게임, 웹서핑 등)
- Scientific Application
  - I/O 작업 없이 CPU만 굉장히 오래 쓰는 프로그램
